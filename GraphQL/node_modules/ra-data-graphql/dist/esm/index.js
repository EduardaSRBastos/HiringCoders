var w=Object.defineProperty,Z=Object.defineProperties;var ee=Object.getOwnPropertyDescriptors;var d=Object.getOwnPropertySymbols;var Y=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var L=(e,t,o)=>t in e?w(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,a=(e,t)=>{for(var o in t||(t={}))Y.call(t,o)&&L(e,o,t[o]);if(d)for(var o of d(t))x.call(t,o)&&L(e,o,t[o]);return e},m=(e,t)=>Z(e,ee(t));var i=(e,t)=>w(e,"name",{value:t,configurable:!0});var l=(e,t)=>{var o={};for(var n in e)Y.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(e!=null&&d)for(var n of d(e))t.indexOf(n)<0&&x.call(e,n)&&(o[n]=e[n]);return o};import Ae from"lodash/merge";import Re from"lodash/get";import Q from"pluralize";import{HttpError as j,GET_LIST as q,GET_ONE as U,GET_MANY as F,GET_MANY_REFERENCE as $,CREATE as B,UPDATE as V,DELETE as W,DELETE_MANY as Qe,UPDATE_MANY as ge}from"ra-core";import{ApolloClient as C,HttpLink as te,InMemoryCache as G}from"@apollo/client";var k=i(e=>{if(!e)return new C({cache:new G().restore({})});let s=e,{cache:t=new G().restore({}),uri:o,link:n=o?new te({uri:o}):void 0}=s,r=l(s,["cache","uri","link"]);return new C(a({link:n,cache:t},r))},"default");import{GET_LIST as oe,GET_ONE as ne,GET_MANY as re,GET_MANY_REFERENCE as ie,CREATE as se,UPDATE as ae,UPDATE_MANY as pe,DELETE as ce,DELETE_MANY as ue}from"ra-core";var A=[oe,re,ie,ne],R=[se,ae,ce,pe,ue],E=A.concat(R);import{getIntrospectionQuery as le}from"graphql";import{gql as ye}from"@apollo/client";var O,D=i(async(e,t)=>O||(O=de(e,t),O),"introspectSchema"),de=i(async(e,t)=>{let o=t.schema?t.schema:await me(e),n=Ee(o),r=Oe(o),s=Te(r,n,t);return{types:r,queries:n,resources:s,schema:o}},"runSchemaIntrospection"),me=i(e=>e.query({fetchPolicy:"network-only",query:ye`
                ${le()}
            `}).then(({data:{__schema:t}})=>t),"fetchSchema"),Ee=i(e=>e.types.reduce((t,o)=>{var n,r;return o.name!==((n=e.queryType)==null?void 0:n.name)&&o.name!==((r=e.mutationType)==null?void 0:r.name)&&o.fields?t:[...t,...o.fields||[]]},[]),"getQueriesFromSchema"),Oe=i(e=>e.types.filter(t=>t.name!==(e.queryType&&e.queryType.name)&&t.name!==(e.mutationType&&e.mutationType.name)),"getTypesFromSchema"),Te=i((e,t,o)=>e.filter(r=>fe(r,t,o)).map(r=>Pe(r,t,o)),"getResources"),fe=i((e,t,o)=>Ie(e,o)?!0:he(e,o)?!1:Object.keys(o.operationNames).map(s=>o.operationNames[s](e)).some(s=>t.find(({name:p})=>p===s)),"isResource"),Ie=i((e,{include:t}={})=>Array.isArray(t)?t.includes(e.name):typeof t=="function"?t(e):!1,"isResourceIncluded"),he=i((e,{exclude:t}={})=>Array.isArray(t)?t.includes(e.name):typeof t=="function"?t(e):!1,"isResourceExcluded"),Pe=i((e,t,o)=>E.reduce((n,r)=>{let s=t.find(({name:p})=>o.operationNames[r]&&p===o.operationNames[r](e));return s?m(a({},n),{[r]:s}):n},{type:e}),"buildResource");var rt=A,it=R,st=E,be={getList:q,getMany:F,getManyReference:$,getOne:U,create:B,delete:W,deleteMany:Qe,update:V,updateMany:ge},Se={resolveIntrospection:D,introspection:{operationNames:{[q]:e=>`all${Q(e.name)}`,[U]:e=>`${e.name}`,[F]:e=>`all${Q(e.name)}`,[$]:e=>`all${Q(e.name)}`,[B]:e=>`create${e.name}`,[V]:e=>`update${e.name}`,[W]:e=>`delete${e.name}`},exclude:void 0,include:void 0}},H=i((e,t,o)=>typeof e=="function"?e(o,t):e,"getOptions"),at=i(async e=>{let S=Ae({},Se,e),{client:t,clientOptions:o,introspection:n,resolveIntrospection:r,buildQuery:s,override:p={}}=S,g=l(S,["client","clientOptions","introspection","resolveIntrospection","buildQuery","override"]);p&&process.env.NODE_ENV==="production"&&console.warn("The override option is deprecated. You should instead wrap the buildQuery function provided by the dataProvider you use.");let T=t||k(o),b;return new Proxy(ve,{get:(Ne,f)=>{if(typeof f=="symbol"||f==="then")return;let c=be[f];return async(u,I)=>{n&&(b=await r(T,n));let _=s(b),v=Re(p,`${u}.${c}`),N=v?a(a({},_(c,u,I)),v(I)):_(c,u,I),{parseResponse:M}=N,y=l(N,["parseResponse"]);if(_e(y.query)==="query"){let K=a(m(a({},y),{fetchPolicy:"network-only"}),H(g.query,c,u));return T.query(K).then(X=>M(X)).catch(z)}let J=a({mutation:y.query,variables:y.variables},H(g.mutation,c,u));return T.mutate(J).then(M).catch(z)}}})},"default"),z=i(e=>{var t,o;throw(e==null?void 0:e.networkError)?new j((t=e==null?void 0:e.networkError)==null?void 0:t.message,(o=e==null?void 0:e.networkError)==null?void 0:o.statusCode):new j(e.message,200,e)},"handleError"),_e=i(e=>{if(e&&e.definitions&&e.definitions.length>0)return e.definitions[0].operation;throw new Error("Unable to determine the query operation")},"getQueryOperation"),ve={create:()=>Promise.resolve({data:null}),delete:()=>Promise.resolve({data:null}),deleteMany:()=>Promise.resolve({data:[]}),getList:()=>Promise.resolve({data:[],total:0}),getMany:()=>Promise.resolve({data:[]}),getManyReference:()=>Promise.resolve({data:[],total:0}),getOne:()=>Promise.resolve({data:null}),update:()=>Promise.resolve({data:null}),updateMany:()=>Promise.resolve({data:[]})};export{st as ALL_TYPES,it as MUTATION_TYPES,rt as QUERY_TYPES,at as default,D as introspectSchema,he as isResourceExcluded,Ie as isResourceIncluded};
//# sourceMappingURL=index.js.map